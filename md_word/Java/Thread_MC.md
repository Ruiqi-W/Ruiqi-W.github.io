# 多线程

## 一、线程创建的四种方式

1.  **继承Thread类**：先调用 start() 方法，然后用 run() 方法创建线程；

   > 缺点：Java是单继承，所以如果使用线程的类已经有父类，就不能使用这种方式创建线程   

2. **实现Runnable接口**：重载 run() 方法，这种方法没有返回值；

3. **实现Callable接口**：重写 call() 方法，创建有返回结果的线程。也可以通过 Future(接口) / FutureTask(实现类) ，创建有返回结果的线程；

   > + Callable 是线程异步执行的结果。如果有A和B两个线程，B的业务逻辑需要确认A线程的执行结果。
   >
   > + Callable可以抛出异常，Runnable 不可以抛出异常
   >
   > + FutureTask 是 Runnable 和 Future 的实现类
   >
   >   > Future 的主要方法：
   >   >
   >   > + get() 返回任务结束后返回一个结果，如果调用时工作没结束，回阻塞线程，直到任务结束；
   >   > + cancel() 停止任务，如果任务可以停止，返回 true ；如果任务已经完成、已经停止或者无法停止，则返回false；
   >   > + isDone() 判断方法是完成
   >   > + isCancel() 判断方法是取消
   >
   > + RunnableFuture ，这个接口同时继承了Future和Runnable接口，在成功执行 run() 方法后，可以通过 Future 访问执行结果。这个接口的实现类是 FutureTask，这个类提供了 Future 的基本实现，实现了启动和取消一个计算、查询计算是否完成、恢复计算结果。
   >
   >   ![image-20200312102203978](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200312102203978.png)
   >
   > + 
   >
   > + 
   >
   >   

4. **使用Executors线程池**：

## 二、线程安全

### 1. String、StringBuffer、StringBuilder

|                            单元格                            |                            单元格                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                         StringBuffer                         |                        StringBulider                         |
|             线程安全（方法用 synchronized 修饰）             |                          线程不安全                          |
| 缓冲区（ StringBuffer 每次获取 toString 都会直接使用缓冲区的 toStringCache 来构造字符） | 无缓冲区（ StringBuilder 每次需要复制一次字符串数组，再构造一个字符串） |
|                     性能不如StringBuffer                     |          性能大于StringBuilder（方法没有加锁同步）           |

>+ StringBuffer 适用于多线程在造作同一个 StringBuffer 的场景，单线程场合更适合 StringBuilder ；
>+ String 为字符串常量，指向一个地址；而 StringBuffer 和 StringBuilder 是字符串变量；
>+ Java9 改进了字符串的实现方式，使用 byte[] 数组，所以字符串每个字符只占一个字节；以前用的是 char[] 数组，每个字节占用两个字节；

### 2.Vector、ArrayList、LinkedList

>|          |                Vector                |                          ArrayList                           | LinkedList                                                   |
>| -------- | :----------------------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ |
>| 性能     |                效率低                | 底层数据结构是数组，适合随机查找和遍历，不适合插入和删除，线程不安全，效率高 | 底层数据结构是链表，适合数据的动态插入和删除，随机访问和遍历速度比较慢，线程不安全，效率高 |
>| 同步     |           可同步，线程安全           |        不可同步，不是线程安全，单线程推荐用 ArrayList        |                                                              |
>| 数据增长 | 插入元素时，如果空间不够，会自动扩容 |             插入元素时，如果空间不够，会自动扩容             |                                                              |
>
>+ vector( 线程安全 )：Vector 与 ArrayList 一样，也是通过数组实现的。但是 Vector 支持线程同步，就是说某一时刻只能有一个线程能够操作 Vector ，避免了多线程同时操作引起的不一致行。但是实现同步花费很高，所以 Vector 访问比较慢（增：vec.add(); 删：vec.remove(); 查：get(); 改：ve.set()）
>+ ArrayList 最常用的实现类是 list ，内部是通过数组实现的，允许对数据进行快速访问。但是当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动，代价比较高。因此适合随机查找和遍历；
>+ LinkedList 通过链表结构实现，适合数组的动态插入和删除；

### 3.HashTable、HashMap、HashSet

| HashTable                                                    | HashMap                       | HashSet            |
| ------------------------------------------------------------ | ----------------------------- | ------------------ |
| 线程安全                                                     | 非线程安全                    | 非线程安全         |
| 存储采用（Key-Value）方式存储。但是不允许有 null 存在，否则抛出 NullPointerException 异常 | 存储采用（Key-Value）方式存储 | 基于Has和Map实现   |
| 遍历使用 Enumeration 列举                                    | 遍历使用 Iterator 迭代器实现  | 不能保证数据的有序 |

> + HashMap 是基于哈希表的 Map 接口实现的，以key-value 形式存在。系统根据 Hash 算法计算 key-value 的存储位置，来保证能快速存取 key-value 对。

### 4. TreeSet、TreeMap

>+ TreeSet 和 TreeMap 都是非线程安全的；
>+ TreeSet：基于TreeMap 实现，支持排序；
>
>+ TreeMap：基于红黑树的 Map 实现，是非线程安全的

##三、锁

### 1.锁分类(ReentrantLock ,Synchronized)

> |                公平锁                |                           非公平锁                           |
> | :----------------------------------: | :----------------------------------------------------------: |
> |  指多个线程按照申请锁的顺序来获取锁  |  指多个线程获取所得顺序不是按照申请顺序，后来的可能先获得锁  |
> |                                      | 非公平锁一上来就试图获得锁，如果失败，则采用公平锁的方式回到末尾排队。在高并发的情况下可能造成优先级反转或者饥饿现象 |
> |                                      |                   优点在于吞吐量比公平锁大                   |
> |            ReentrantLock             |                         Synchronized                         |
> | ReentrantLock 是递归锁，可以避免死锁 |             Synchronized 是递归锁，可以避免死锁              |
> |        ReentrantLock 是独占锁        |                     Synchronized 独占锁                      |
>
> > + 递归锁（可重入锁）：同一线程外层方法获得锁后，内层递归方法仍能过获得该锁代码。
> > + 独占锁：锁一次只能被一个线程锁持有

###2.乐观锁和悲观锁

>  
>
> |                            悲观锁                            |                            乐观锁                            |
> | :----------------------------------------------------------: | :----------------------------------------------------------: |
> | 共享资源每次只给一个线程使用，其他线程阻塞，用完再把资源让给其他线程（每次获取资源都会上锁） | 获取数据时不上锁，但是在更新时会判断是否有人更新数据（可以使用版本号机制和 CAS 算法实现） |
> |                Synchronized 和 ReentrantLock                 |                                                              |
> |                        多写的场景使用                        |                 多读场景使用，可以提高吞吐量                 |
>
> + 使用场景：
>
>   > + 乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量
>   > + 多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
>
> + 乐观锁的实现方式
>
>   > + 版本号机制：在数据库表中增加数据版本字段（version），表示数据修改次数。提交更新时，更新版本号，且提交版本必须大于当前版本号；
>   > + CAS 算法：涉及三个操作数 V (需要读写的内存值)、A (进行比较的值)、B (准备写入的新值)。当 V 的值等于 A 的时候，CAS 通过原子方式用新值 B 更新 V，且不断重试（自旋操作）；

## 常见问题

### 1. yield 方法

>+ 作用：暂停当前执行的线程对象，并执行其他线程。yield() 是让当前运行线程回到可运行状态，以允许其他拥有相同优先级的线程获得运行机会。但是，无法保证让线程让步，当前线程仍具有可能再次被选中。



